### *Принципы SOLID*
* **S - Single Responsibility Principle** - принцип единственной ответственности. 
У нас в программе есть класс StudentService, в котором есть метод create, создающий нового студета с максимальным id. 
Предположим, мы хотим добавить метод создания нового студента-отличника createExcellentStudent. Добавление этого метода в класс
  StudentService нарушит границы ответственности этого класса, поэтому метод createExcellentStudent должен находиться в отдельном 
классе ExcellentStudentService.
* **O - Open closed Principle** - принцип открытости-закрытости.
Предположим в StudentService.create() мы решили дополнить метод функцией сбора фамилии и инициалов студентов в отдельный список.
Однако внесение изменений в метод create() нарушит принцип открытости-закрытости, т.к. программные сущности 
(классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения. Поэтому создадим отдельный метод
getStudentFio() в классе StudentService.
* **L - Liskov substitution Principle** - принцип подстановки Барбары Лисков.
На примере того же StudentService.create(). Если бы мы дополнили метод новым функционалом, 
мы бы нарушили принцип подстановки Барбары Лисков, т.к. метод StudentService.create() наследуется от интефейса UserService,
и по замыслу должен просто создавать новый экземпляр класса Student, и ничего более.
* **I -  Interface Segregation Principle** - принцип разделения интерфейсов.
  Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.
Также не стоит нагружать интерфейсы методами, не входящими в их зону ответственности.
  Этот принцип похож на принцип единой ответственности SRP, SRP относится к классам, а ISP — к интерфейсам. В частности класс User имеет три интерфейса для разных задач, UserController, UserService и UserVew, таким образом используются только те методы которые им необходимы, что улучшает код и позволяет лучше поддерживать и расширять его в будущем.
* **D - Dependency Inversion Principle** - принцип инверсии зависимостей.
  Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Созданный нами класс ExcellentStudent сделаем наследником абстрактного класса User, а класс ExcellentStudentService
от интерфейса UserService. В таком случае наша программа будет соответсвовать принципу инверсии зависимостей.
Теперь все классы в нашей программе зависят от абстракций.
